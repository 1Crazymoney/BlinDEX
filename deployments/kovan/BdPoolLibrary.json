{
  "address": "0x35cDf0804550Fd34202cedfD6Eb20168CF55507D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "col_price",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "collateral_amount_d18",
          "type": "uint256"
        }
      ],
      "name": "calcMint1t1BD",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "bdx_price_fiat_d12",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bdx_amount_d18_d18",
          "type": "uint256"
        }
      ],
      "name": "calcMintAlgorithmicBD",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "collateral_amount_d18",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "col_price",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "global_collat_value",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bdStable_total_supply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "global_collateral_ratio",
          "type": "uint256"
        }
      ],
      "name": "calcRecollateralizeBdStableInner",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xfe768ee63bcff23c4c02a94b43cef3322e5284043c9fd9474424fdc2d7b12d82",
  "receipt": {
    "to": null,
    "from": "0x774289Cb40c98B4f5b64a152BF7e5F94Fee38669",
    "contractAddress": "0x35cDf0804550Fd34202cedfD6Eb20168CF55507D",
    "transactionIndex": 6,
    "gasUsed": "268090",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xdc23d1361557931e2b624701d47e5c33ff762c6a2e38af87d641647d6f2e2eab",
    "transactionHash": "0xfe768ee63bcff23c4c02a94b43cef3322e5284043c9fd9474424fdc2d7b12d82",
    "logs": [],
    "blockNumber": 27232077,
    "cumulativeGasUsed": "439906",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "36185021115f3fccbe06894bb4a1b398",
  "metadata": "{\"compiler\":{\"version\":\"0.6.11+commit.5ef660b1\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"col_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral_amount_d18\",\"type\":\"uint256\"}],\"name\":\"calcMint1t1BD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bdx_price_fiat_d12\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bdx_amount_d18_d18\",\"type\":\"uint256\"}],\"name\":\"calcMintAlgorithmicBD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_amount_d18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collat_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bdStable_total_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collateral_ratio\",\"type\":\"uint256\"}],\"name\":\"calcRecollateralizeBdStableInner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Frax/Pools/BdPoolLibrary.sol\":\"BdPoolLibrary\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Frax/Pools/BdPoolLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.11;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../Math/SafeMath.sol\\\";\\n\\nlibrary BdPoolLibrary {\\n    using SafeMath for uint256;\\n\\n    // Constants for various precisions\\n    uint256 private constant PRICE_PRECISION = 1e12;\\n\\n    struct MintFBD_Params {\\n        uint256 bdx_price_fiat_d12; \\n        uint256 col_price_fiat_d12;\\n        uint256 bdx_amount_d18;\\n        uint256 collateral_amount_d18;\\n        uint256 col_ratio_d12;\\n    }\\n\\n    struct BuybackBDX_Params {\\n        uint256 excess_collateral_fiat_value_d18;\\n        uint256 bdx_price_fiat_d12;\\n        uint256 col_price_fiat_d12;\\n        uint256 bdx_amount_d18;\\n    }\\n\\n    // ================ Functions ================\\n\\n    function calcMint1t1BD(uint256 col_price, uint256 collateral_amount_d18) public pure returns (uint256) {\\n        return (collateral_amount_d18.mul(col_price)).div(1e12);\\n    }\\n\\n    // Must be internal because of the struct\\n    function calcMintFractionalBD(MintFBD_Params memory params) internal pure returns (uint256, uint256) {\\n        // Since solidity truncates division, every division operation must be the last operation in the equation to ensure minimum error\\n        // The contract must check the proper ratio was sent to mint BdStable. We do this by seeing the minimum mintable BdStable based on each amount \\n        uint256 bdx_fiat_value_d18;\\n        uint256 c_fiat_value_d18;\\n        \\n        // Scoping for stack concerns\\n        {    \\n            // fiat amounts of the collateral and the BDX\\n            bdx_fiat_value_d18 = params.bdx_amount_d18.mul(params.bdx_price_fiat_d12).div(1e12);\\n            c_fiat_value_d18 = params.collateral_amount_d18.mul(params.col_price_fiat_d12).div(1e12);\\n        }\\n\\n        uint calculated_bdx_fiat_value_d18 = \\n                    (c_fiat_value_d18.mul(1e12).div(params.col_ratio_d12))\\n                    .sub(c_fiat_value_d18);\\n\\n        uint calculated_bdx_needed = calculated_bdx_fiat_value_d18.mul(1e12).div(params.bdx_price_fiat_d12);\\n\\n        return (\\n            c_fiat_value_d18.add(calculated_bdx_fiat_value_d18),\\n            calculated_bdx_needed\\n        );\\n    }\\n\\n    function calcMintAlgorithmicBD(uint256 bdx_price_fiat_d12, uint256 bdx_amount_d18_d18) public pure returns (uint256) {\\n        return bdx_amount_d18_d18.mul(bdx_price_fiat_d12).div(1e12);\\n    }\\n\\n    function calcRecollateralizeBdStableInner(\\n        uint256 collateral_amount_d18,\\n        uint256 col_price,\\n        uint256 global_collat_value,\\n        uint256 bdStable_total_supply,\\n        uint256 global_collateral_ratio\\n    ) public pure returns (uint256, uint256) {\\n        uint256 collat_value_attempted = collateral_amount_d18.mul(col_price).div(1e12);\\n        uint256 effective_collateral_ratio = global_collat_value.mul(1e12).div(bdStable_total_supply); //returns it in 1e12\\n        uint256 recollat_possible = (global_collateral_ratio.mul(bdStable_total_supply).sub(bdStable_total_supply.mul(effective_collateral_ratio))).div(1e12);\\n\\n        uint256 amount_to_recollat;\\n        if(collat_value_attempted <= recollat_possible){\\n            amount_to_recollat = collat_value_attempted;\\n        } else {\\n            amount_to_recollat = recollat_possible;\\n        }\\n\\n        return (amount_to_recollat.mul(1e12).div(col_price), amount_to_recollat);\\n    }\\n\\n    // Must be internal because of the struct\\n    function calcBuyBackBDX(BuybackBDX_Params memory params) internal pure returns (uint256) {\\n        // If the total collateral value is higher than the amount required at the current collateral ratio then buy back up to the possible BDX with the desired collateral\\n        require(params.excess_collateral_fiat_value_d18 > 0, \\\"No excess collateral to buy back!\\\");\\n\\n        // Make sure not to take more than is available\\n        uint256 bdx_fiat_value_d18 = params.bdx_amount_d18.mul(params.bdx_price_fiat_d12).div(1e12);\\n        require(bdx_fiat_value_d18 <= params.excess_collateral_fiat_value_d18, \\\"You are trying to buy back more than the excess!\\\");\\n\\n        // Get the equivalent amount of collateral based on the market value of BDX provided \\n        uint256 collateral_equivalent_d18 = bdx_fiat_value_d18.mul(1e12).div(params.col_price_fiat_d12);\\n\\n        return (\\n            collateral_equivalent_d18\\n        );\\n    }\\n\\n\\n}\",\"keccak256\":\"0x6456113e8416384816b556995ecf44ad55bb564e92558cea68cfa7fc31c26965\",\"license\":\"MIT\"},\"contracts/Math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\",\"keccak256\":\"0xd59454f079791fa65de99df4f72d7efc0443657dacff0a1e41fcd0542bb5ee71\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6103e4610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c80634e820a3f14610050578063810278f01461007a578063ba8b18081461007a575b600080fd5b61006361005e3660046102c9565b61009a565b6040516100719291906103a0565b60405180910390f35b61008d6100883660046102a8565b61015a565b6040516100719190610397565b600080806100c364e8d4a510006100b78a8a63ffffffff61017e16565b9063ffffffff6101c116565b905060006100e0866100b78964e8d4a5100063ffffffff61017e16565b9050600061011c64e8d4a510006100b76101008a8663ffffffff61017e16565b6101108a8c63ffffffff61017e16565b9063ffffffff61020316565b9050600081841161012e575082610131565b50805b61014a8a6100b78364e8d4a5100063ffffffff61017e16565b9b909a5098505050505050505050565b600061017564e8d4a510006100b7848663ffffffff61017e16565b90505b92915050565b60008261018d57506000610178565b8282028284828161019a57fe5b04146101755760405162461bcd60e51b81526004016101b890610356565b60405180910390fd5b600061017583836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f000000000000815250610245565b600061017583836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f77000081525061027c565b600081836102665760405162461bcd60e51b81526004016101b89190610303565b50600083858161027257fe5b0495945050505050565b600081848411156102a05760405162461bcd60e51b81526004016101b89190610303565b505050900390565b600080604083850312156102ba578182fd5b50508035926020909101359150565b600080600080600060a086880312156102e0578081fd5b505083359560208501359550604085013594606081013594506080013592509050565b6000602080835283518082850152825b8181101561032f57858101830151858201604001528201610313565b818111156103405783604083870101525b50601f01601f1916929092016040019392505050565b60208082526021908201527f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f6040820152607760f81b606082015260800190565b90815260200190565b91825260208201526040019056fea264697066735822122045856394f10d3b72622ffe7f10e0f28a6c26652640e2f1f4269cc1957918529d64736f6c634300060b0033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c80634e820a3f14610050578063810278f01461007a578063ba8b18081461007a575b600080fd5b61006361005e3660046102c9565b61009a565b6040516100719291906103a0565b60405180910390f35b61008d6100883660046102a8565b61015a565b6040516100719190610397565b600080806100c364e8d4a510006100b78a8a63ffffffff61017e16565b9063ffffffff6101c116565b905060006100e0866100b78964e8d4a5100063ffffffff61017e16565b9050600061011c64e8d4a510006100b76101008a8663ffffffff61017e16565b6101108a8c63ffffffff61017e16565b9063ffffffff61020316565b9050600081841161012e575082610131565b50805b61014a8a6100b78364e8d4a5100063ffffffff61017e16565b9b909a5098505050505050505050565b600061017564e8d4a510006100b7848663ffffffff61017e16565b90505b92915050565b60008261018d57506000610178565b8282028284828161019a57fe5b04146101755760405162461bcd60e51b81526004016101b890610356565b60405180910390fd5b600061017583836040518060400160405280601a81526020017f536166654d6174683a206469766973696f6e206279207a65726f000000000000815250610245565b600061017583836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f77000081525061027c565b600081836102665760405162461bcd60e51b81526004016101b89190610303565b50600083858161027257fe5b0495945050505050565b600081848411156102a05760405162461bcd60e51b81526004016101b89190610303565b505050900390565b600080604083850312156102ba578182fd5b50508035926020909101359150565b600080600080600060a086880312156102e0578081fd5b505083359560208501359550604085013594606081013594506080013592509050565b6000602080835283518082850152825b8181101561032f57858101830151858201604001528201610313565b818111156103405783604083870101525b50601f01601f1916929092016040019392505050565b60208082526021908201527f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f6040820152607760f81b606082015260800190565b90815260200190565b91825260208201526040019056fea264697066735822122045856394f10d3b72622ffe7f10e0f28a6c26652640e2f1f4269cc1957918529d64736f6c634300060b0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}